@using ChatContractsLibrary
@inject IJSRuntime JSRuntime
@if (ConnectedUsers is not null && ConnectedUsers.Count > 0)
{
    @foreach (var user in ConnectedUsers)
    {
        @if(user.UserId != this.LogonUserId)
        {
            // Find the last message in the conversation with this user
            var lastMessage = user.Messages
                .Where(m => (m.FromUserId == user.UserId && m.ToUserId == this.LogonUserId) || (m.FromUserId == this.LogonUserId && m.ToUserId == user.UserId))
                .OrderByDescending(m => m.Timestamp)
                .FirstOrDefault();
            // Show notification if the last message is from the other user, is unread, and is to me
            var showNotification = lastMessage != null && lastMessage.Unread == true && lastMessage.FromUserId == user.UserId && lastMessage.ToUserId == this.LogonUserId;

            <tr style="cursor: pointer; height: 30px"
                @key="user.UserId"
                @onclick="async () => await SelectUser(user.UserId!)">
                <td>
                    @user.UserName
                    @if (string.IsNullOrWhiteSpace(user.ConnectionId))
                    {
                        <span class="text-muted small ms-2">(Disconnected)</span>
                    }
                </td>
                <td>
                    @if (showNotification)
                    {
                        <div class="unread-indicator">
                            1
                        </div>
                    }
                </td>
            </tr>
        }
    }
}
else
{
    <p>No users connected.</p>
}

@code{
    [Parameter]
    public List<ConnectedUser>? ConnectedUsers { get; set; }
    [Parameter]
    public string? LogonUserId { get; set; }

    [Parameter]
    public EventCallback<ConnectedUser> OnUserSelected { get; set; }
    public void ClearUnreadMessagCount (string userId)
    {
        this.ConnectedUsers?.FirstOrDefault(u => u.UserId == userId)?
        .Messages.ForEach(m => m.Unread = false);

        StateHasChanged();
    }

    private async Task SelectUser(string? userId)
    {
        if (string.IsNullOrWhiteSpace(userId))
            return;

        var targetUser = ConnectedUsers?.FirstOrDefault(u => u.UserId == userId);
        if(targetUser is not null)
        {
            targetUser.Messages.ForEach(m => m.Unread = false); // Mark messages as read when user is selected
            await OnUserSelected.InvokeAsync(targetUser);
        }
    }

    private async Task ReceiveMessage(string fromUserId, string fromConnectionId, string message)
{
    var fromUser = ConnectedUsers.FirstOrDefault(u => (u.ConnectionId != null && u.ConnectionId == fromConnectionId) || u.UserId == fromUserId);
    if(fromUser is not null)
    {
        fromUser.Messages.Add(new ChatMessage
        {
            FromUserId = fromUserId,
            ToUserId = this.LogonUserId,
            Message = message,
            Unread = fromUserId != this.LogonUserId // Only mark as unread if not sent by me
        });

        await JSRuntime.InvokeVoidAsync("playsound", "/sounds/notification.mp3");
        StateHasChanged();
    }
}
}
